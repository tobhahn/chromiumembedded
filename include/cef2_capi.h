// Copyright (c) 2010 Marshall A. Greenblatt. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//    * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//    * Neither the name of Google Inc. nor the name Chromium Embedded
// Framework nor the names of its contributors may be used to endorse
// or promote products derived from this software without specific prior
// written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// ---------------------------------------------------------------------------
//
// This file was generated by the CEF translator tool and should not edited
// by hand. See the translator.README.txt file in the tools directory for
// more information.
//

#ifndef _CEF2_CAPI_H
#define _CEF2_CAPI_H

#ifdef __cplusplus
extern "C" {
#endif

#include "cef2_export.h"
#include "cef2_string.h"
#include "cef2_types.h"


// This function should be called once when the application is started to
// initialize CEF.  A return value of true (1) indicates that it succeeded and
// false (0) indicates that it failed. Set |chrome_path| to the full path of the
// chrome.exe file. If |chrome_path| is NULL then chome.exe is assumed to exist
// in the current working directory. Set |multi_threaded_message_loop| to true
// (1) to have the message loop run in a separate thread.  If
// |multi_threaded_message_loop| is false (0) than the
// cef_do_message_loop_work() function must be called from your message loop.
CEF_EXPORT int cef_initialize(const wchar_t* chrome_path,
    int multi_threaded_message_loop);

// This function should be called once before the application exits to shut down
// CEF and destroy any created windows.
CEF_EXPORT void cef_shutdown();

// Perform message loop processing.  Has no affect if the browser UI loop is
// running in a separate thread.
CEF_EXPORT void cef_do_message_loop_work();

// Create a new cef_profile_t object or return the existing cef_profile_t object
// that uses the specified |user_profile| directory.  If |user_profile| is NULL
// the default directory will be used.
CEF_EXPORT struct _cef_profile_t* cef_create_profile(
    const wchar_t* user_profile);

typedef struct _cef_base_t
{
  // Size of the data structure.
  size_t size;

  // Increment the reference count.
  int (CEF_CALLBACK *add_ref)(struct _cef_base_t* self);
  // Decrement the reference count.  Delete this object when no references
  // remain.
  int (CEF_CALLBACK *release)(struct _cef_base_t* self);
  // Returns the current number of references.
  int (CEF_CALLBACK *get_refct)(struct _cef_base_t* self);

} cef_base_t;


// Check that the structure |s|, which is defined with a cef_base_t member named
// |base|, is large enough to contain the specified member |f|.
#define CEF_MEMBER_EXISTS(s, f)   \
  ((int)&((s)->f) - (int)(s) + sizeof((s)->f) <= (s)->base.size)

#define CEF_MEMBER_MISSING(s, f)  (!CEF_MEMBER_EXISTS(s, f) || !((s)->f))


// Implement this structure to handle browser events.  All functions in this
// structure will be called on the UI thread.
typedef struct _cef_browser_listener_t
{
  // Base structure.
  cef_base_t base;

  // Called when a browser is created.
  void (CEF_CALLBACK *on_create)(struct _cef_browser_listener_t* self,
      struct _cef_browser_t* browser);

  // Called when a browser is destroyed.
  void (CEF_CALLBACK *on_destroy)(struct _cef_browser_listener_t* self,
      struct _cef_browser_t* browser);

} cef_browser_listener_t;


// Implement this structure to handle tab events.  All functions in this
// structure will be called on the UI thread.
typedef struct _cef_tab_listener_t
{
  // Base structure.
  cef_base_t base;

  // Called when a tab is created.
  void (CEF_CALLBACK *on_create)(struct _cef_tab_listener_t* self,
      struct _cef_tab_t* tab);

  // Called when a tab is destroyed.
  void (CEF_CALLBACK *on_destroy)(struct _cef_tab_listener_t* self,
      struct _cef_tab_t* tab);

  // Called when the address changes.
  void (CEF_CALLBACK *on_address_change)(struct _cef_tab_listener_t* self,
      struct _cef_tab_t* tab, const wchar_t* url);

  // Called when the page title changes.
  void (CEF_CALLBACK *on_title_change)(struct _cef_tab_listener_t* self,
      struct _cef_tab_t* tab, const wchar_t* title);

  // Called when the navigation state changes.
  void (CEF_CALLBACK *on_nav_state_change)(struct _cef_tab_listener_t* self,
      struct _cef_tab_t* tab, int can_go_back, int can_go_forward);

  // Called when the selection state changes.
  void (CEF_CALLBACK *on_select_change)(struct _cef_tab_listener_t* self,
      struct _cef_tab_t* tab, int selected);

  // Called when the page load has started.
  void (CEF_CALLBACK *on_load_start)(struct _cef_tab_listener_t* self,
      struct _cef_tab_t* tab);

  // Called when the page load has stopped.
  void (CEF_CALLBACK *on_load_stop)(struct _cef_tab_listener_t* self,
      struct _cef_tab_t* tab);

} cef_tab_listener_t;


// In Chromium, each browser process is associated with a unique user profile.
// This structure represents the connection between the current CEF host process
// and the Chromium browser process for a given user profile. Multiple CEF host
// processes can share the same Chromium browser process by passing the same
// user profile argument to cef_create_profile(). The Chromium browser process
// for a given user profile will be created when the first browser window for
// that user profile is created and destroyed when the last browser window for
// that user profile is destroyed. All functions exposed by this structure
// should be thread safe.
typedef struct _cef_profile_t
{
  // Base structure.
  cef_base_t base;

  // Add a browser listener.
  void (CEF_CALLBACK *add_browser_listener)(struct _cef_profile_t* self,
      const wchar_t* id_string, struct _cef_browser_listener_t* listener);

  // Remove a browser listener.
  void (CEF_CALLBACK *remove_browser_listener)(struct _cef_profile_t* self,
      const wchar_t* id_string);

  // Add a tab listener.
  void (CEF_CALLBACK *add_tab_listener)(struct _cef_profile_t* self,
      const wchar_t* id_string, struct _cef_tab_listener_t* listener);

  // Remove a tab listener.
  void (CEF_CALLBACK *remove_tab_listener)(struct _cef_profile_t* self,
      const wchar_t* id_string);

  // Destroy the profile.
  void (CEF_CALLBACK *destroy)(struct _cef_profile_t* self);

  // Creates a new browser instance. If |parent| is NULL then the browser window
  // will be created as a framed "popup" window parented to the desktop. The
  // |xpos|, |ypos|, |width| and |height| values specify the positioning of the
  // browser window in parent window client coordinates. The |command_line|
  // argument will be passed to the Chromium process and supports all standard
  // Chromium command-line flags.  This function call will not block. All
  // registered BrowserListener objects will be notified on the UI thread once
  // the browser window has been created.
  struct _cef_browser_t* (CEF_CALLBACK *create_browser)(
      struct _cef_profile_t* self, const wchar_t* id_string,
      cef_window_handle_t parent, int xpos, int ypos, int width, int height,
      const wchar_t* command_line);

} cef_profile_t;


// This structure represents a browser window. Browser windows may have a tab
// strip that contains one or more tabs.
typedef struct _cef_browser_t
{
  // Base structure.
  cef_base_t base;

  // Returns the cef_profile_t that owns this browser.
  struct _cef_profile_t* (CEF_CALLBACK *get_profile)(
      struct _cef_browser_t* self);

  // Destroy the browser window.
  void (CEF_CALLBACK *destroy)(struct _cef_browser_t* self);

  // Returns the ID string associated with this browser.
  // The resulting string must be freed by calling cef_string_free().
  cef_string_t (CEF_CALLBACK *get_id_string)(struct _cef_browser_t* self);

  // Retrieve the window handle for this browser.
  cef_window_handle_t (CEF_CALLBACK *get_window_handle)(
      struct _cef_browser_t* self);

  // Create a new tab object. The tab will be created at the specified zero-
  // based index in the tab strip.  If |foreground| is true (1) the new tab will
  // be selected.
  struct _cef_tab_t* (CEF_CALLBACK *create_tab)(struct _cef_browser_t* self,
      int index, const wchar_t* url, const wchar_t* referrer, int foreground);

  // Returns the number of tabs that currently exist in the tab stip for this
  // browser.
  int (CEF_CALLBACK *get_tab_count)(struct _cef_browser_t* self);

  // Return the tab at the specified zero-based index.
  struct _cef_tab_t* (CEF_CALLBACK *get_tab)(struct _cef_browser_t* self,
      int index);

  // Return the currently selected tab.
  struct _cef_tab_t* (CEF_CALLBACK *get_selected_tab)(
      struct _cef_browser_t* self);

} cef_browser_t;


// This structure represents a tab in a browser window's tab strip.
typedef struct _cef_tab_t
{
  // Base structure.
  cef_base_t base;

  // Returns the cef_browser_t that owns this tab.
  struct _cef_browser_t* (CEF_CALLBACK *get_browser)(struct _cef_tab_t* self);

  // Destroy the tab.
  void (CEF_CALLBACK *destroy)(struct _cef_tab_t* self);

  // Returns the index of this tab in the tab strip.
  int (CEF_CALLBACK *get_index)(struct _cef_tab_t* self);

  // Returns true (1) if this tab is selected in the tab strip.
  int (CEF_CALLBACK *is_selected)(struct _cef_tab_t* self);

  // Select this tab in the tab strip.
  void (CEF_CALLBACK *select)(struct _cef_tab_t* self);

  // Returns true (1) if this tab can navigate backwards.
  int (CEF_CALLBACK *can_go_back)(struct _cef_tab_t* self);

  // Navigate backwards.
  void (CEF_CALLBACK *go_back)(struct _cef_tab_t* self);

  // Returns true (1) if this tab can navigate forwards.
  int (CEF_CALLBACK *can_go_forward)(struct _cef_tab_t* self);

  // Navigate backwards.
  void (CEF_CALLBACK *go_forward)(struct _cef_tab_t* self);

  // Returns true (1) if this tab is currently loading.
  int (CEF_CALLBACK *is_loading)(struct _cef_tab_t* self);

  // Reload the current page.
  void (CEF_CALLBACK *reload)(struct _cef_tab_t* self);

  // Stop loading the page.
  void (CEF_CALLBACK *stop_load)(struct _cef_tab_t* self);

  // Returns the current address for this tab.
  // The resulting string must be freed by calling cef_string_free().
  cef_string_t (CEF_CALLBACK *get_address)(struct _cef_tab_t* self);

  // Returns the current title for this tab.
  // The resulting string must be freed by calling cef_string_free().
  cef_string_t (CEF_CALLBACK *get_title)(struct _cef_tab_t* self);

  // Execute undo in the currently active selection context.
  void (CEF_CALLBACK *undo)(struct _cef_tab_t* self);

  // Execute redo in the currently active selection context.
  void (CEF_CALLBACK *redo)(struct _cef_tab_t* self);

  // Execute cut in the currently active selection context.
  void (CEF_CALLBACK *cut)(struct _cef_tab_t* self);

  // Execute copy in the currently active selection context.
  void (CEF_CALLBACK *copy)(struct _cef_tab_t* self);

  // Execute paste in the currently active selection context.
  void (CEF_CALLBACK *paste)(struct _cef_tab_t* self);

  // Execute delete in the currently active selection context.
  void (CEF_CALLBACK *del)(struct _cef_tab_t* self);

  // Execute select all in the currently active selection context.
  void (CEF_CALLBACK *select_all)(struct _cef_tab_t* self);

  // Execute printing in the currently active frame.
  void (CEF_CALLBACK *print)(struct _cef_tab_t* self);

  // Execute view source in the currently active frame.
  void (CEF_CALLBACK *view_source)(struct _cef_tab_t* self);

  // Load the specified |url| in the main frame.
  void (CEF_CALLBACK *load_address)(struct _cef_tab_t* self, const wchar_t* url,
      const wchar_t* referrer);

  // Execute a string of JavaScript code in the specified |frame_xpath|. Leave
  // |frame_xpath| NULL to execute in the main frame.
  void (CEF_CALLBACK *execute_java_script)(struct _cef_tab_t* self,
      const wchar_t* frame_xpath, const wchar_t* jscript);

} cef_tab_t;


#ifdef __cplusplus
}
#endif

#endif // _CEF2_CAPI_H
